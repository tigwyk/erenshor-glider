## Codebase Patterns
- Erenshor is a Unity game using BepInEx 5.x (Mono) for modding
- Use Harmony patches to hook into game methods (Prefix/Postfix)
- GameData singleton is the central access point for all game state
- GameData.PlayerControl.transform.position for player coordinates
- GameData.PlayerControl.Myself for player Character reference
- GameData.PlayerControl.CurrentTarget for current target
- Character.MyStats for health/mana/stats access
- Use BepInEx.Configuration for mod settings
- Target .NET Framework 4.7.2 or .NET Standard 2.0
- Build with `dotnet build` in project root (requires .NET SDK 8.0+)
- Plugin entry point is Plugin.cs with [BepInPlugin] attribute
- Use GameStubs/ for compile-time type safety without game DLLs
- nuget.config required with BepInEx NuGet feed (https://nuget.bepinex.dev/v3/index.json)
- GameState/ contains all game state reading logic
- Position tracking: Plugin.PositionTracker.CurrentPosition for cached position
- Vitals tracking: Plugin.PositionTracker.CurrentVitals for cached vitals
- CharacterStats has: CurrentHP, MaxHP, CurrentMP, MaxMP, Level, CurrentXP, XPToLevel
- Combat state tracking: Plugin.PositionTracker.CurrentCombatState for cached combat state
- PlayerCombat.InCombat for combat state, CastSpell.Casting for casting state, Character.Dead for alive/dead
- GameData.PlayerCombat for player combat controller
- GameData.PlayerControl.PlayerSpells for player spell casting component
- Target tracking: Plugin.PositionTracker.CurrentTargetInfo for cached target info
- Character.CharacterName for target/character display names
- Character.MyFaction for hostility (Faction enum: Player, Enemy, Neutral, Friendly)

---

## 2026-02-05 - US-001
- What was implemented:
  - Researched Erenshor's technical architecture
  - Documented Unity engine and BepInEx modding framework
  - Identified key game classes: GameData, Character, PlayerCombat, Hotkeys, Spell, Skill
  - Documented methods for reading game state (position, health, target, combat)
  - Documented methods for sending inputs (auto-attack, abilities, movement)
  - Listed all 6 character classes
- Files changed:
  - docs/technical-integration.md (created)
  - prd.json (committed with project)
- **Learnings for future iterations:**
  - Existing mods on GitHub (ErenshorQoL, ExtendedHotbars) are excellent references for API usage
  - GameData is a static singleton - most game state is accessed through it
  - CharacterStats likely has CurrentHP, MaxHP, CurrentMP, MaxMP properties (needs verification)
  - Private methods like Hotkeys.DoHotkeyTask() need reflection to call
  - Movement input simulation may be needed vs direct position manipulation
  - NPC.AggroOn() can be hooked to detect when player is attacked
  - Character.DoDeath() can be hooked to detect deaths
---

## 2026-02-05 - US-002
- What was implemented:
  - Created C# BepInEx 5.x plugin project structure
  - Set up ErenshorGlider.sln and ErenshorGlider.csproj with proper dependencies
  - Configured BepInEx.Core and UnityEngine.Modules NuGet packages
  - Added Plugin.cs with BepInPlugin attribute and basic initialization
  - Added PluginInfo.cs with plugin metadata constants
  - Created folder structure: src/ErenshorGlider/, profiles/, waypoints/
  - Added .editorconfig for C# code style consistency
  - Added .gitignore for build artifacts
  - Added Directory.Build.props for shared build configuration
  - Created README.md with setup and build instructions
- Files changed:
  - ErenshorGlider.sln (created)
  - src/ErenshorGlider/ErenshorGlider.csproj (created)
  - src/ErenshorGlider/Plugin.cs (created)
  - src/ErenshorGlider/PluginInfo.cs (created)
  - .editorconfig (created)
  - .gitignore (created)
  - Directory.Build.props (created)
  - README.md (created)
  - profiles/.gitkeep (created)
  - waypoints/.gitkeep (created)
- **Learnings for future iterations:**
  - Project uses SDK-style csproj with .NET Framework 4.7.2 target
  - BepInEx.Core 5.x and BepInEx.Analyzers packages provide base plugin functionality
  - UnityEngine.Modules 2022.3.20 provides Unity types (may need adjustment if Erenshor uses older Unity)
  - BepInEx.PluginInfoProps enables automatic plugin metadata generation
  - Plugin.cs inherits from BaseUnityPlugin which is a MonoBehaviour
  - Logger is accessible via base.Logger in Awake()
  - Build command: `dotnet build` (requires .NET SDK 8.0+)
---

## 2026-02-05 - US-003
- What was implemented:
  - Created PlayerPosition struct with X, Y, Z coordinates
  - Created GameStateReader class to read position from GameData.PlayerControl.transform.position
  - Created PositionTracker MonoBehaviour with 10Hz default update rate (configurable 1-100Hz)
  - Added GameStubs folder with stub types for compile-time safety without game DLLs
  - Added nuget.config with BepInEx NuGet feed for package resolution
  - Integrated PositionTracker into Plugin.Awake()
- Files changed:
  - src/ErenshorGlider/GameState/PlayerPosition.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (created)
  - src/ErenshorGlider/GameState/PositionTracker.cs (created)
  - src/ErenshorGlider/GameStubs/GameData.cs (created)
  - src/ErenshorGlider/Plugin.cs (modified)
  - nuget.config (created)
- **Learnings for future iterations:**
  - GameStubs approach allows building without game DLLs; swap to real types when Assembly-CSharp.dll is available
  - BepInEx packages are on separate NuGet feed (https://nuget.bepinex.dev) - must add to nuget.config
  - Position tracking via Unity Update() loop with Time.deltaTime accumulation for configurable Hz
  - Use events (OnPositionUpdated) for loose coupling between components
  - readonly struct for immutable data like positions
---

## 2026-02-05 - US-004
- What was implemented:
  - Created PlayerVitals struct with CurrentHealth, MaxHealth, CurrentMana, MaxMana, Level, CurrentXP, XPToLevel
  - Added percentage helpers (HealthPercent, ManaPercent, XPPercent) and threshold methods
  - Extended CharacterStats stub with Level, CurrentXP, XPToLevel fields
  - Added GetPlayerVitals(), GetCachedVitals(), UpdateVitals() to GameStateReader
  - Added OnVitalsChanged event for reactive updates
  - Extended PositionTracker to track vitals alongside position at 10Hz
  - Integrated vitals logging in Plugin.cs
- Files changed:
  - src/ErenshorGlider/GameState/PlayerVitals.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
  - src/ErenshorGlider/Plugin.cs (modified)
- **Learnings for future iterations:**
  - Access vitals via GameData.PlayerControl.Myself.MyStats (character stats component)
  - PositionTracker serves as the central state tracker - can be extended for other state
  - Use separate locks for position vs vitals to allow concurrent access
  - readonly struct pattern works well for immutable game state snapshots
  - Percentage helpers (e.g., IsHealthBelowPercent) useful for combat/rest decision thresholds
---

## 2026-02-05 - US-005
- What was implemented:
  - Created CombatState struct with InCombat, IsCasting, IsAlive properties
  - Added helper properties: IsDead, CanAct, IsIdle for decision-making convenience
  - Extended GameStubs with PlayerCombat and CastSpell classes
  - Added Character.Dead field to track alive/dead state
  - Added GameData.PlayerCombat static field
  - Added PlayerControl.PlayerSpells for CastSpell component access
  - Added GetCombatState(), GetCachedCombatState(), UpdateCombatState() to GameStateReader
  - Added OnCombatStateChanged event for reactive updates
  - Extended PositionTracker to track combat state at 10Hz alongside position and vitals
- Files changed:
  - src/ErenshorGlider/GameState/CombatState.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerCombat.InCombat tracks whether player is in combat mode (auto-attack enabled)
  - CastSpell.Casting tracks whether player is currently casting a spell
  - Character.Dead tracks death state - use !Dead for IsAlive
  - PositionTracker now tracks position, vitals, and combat state - serves as central state tracker
  - CombatState helper properties (CanAct, IsIdle) useful for state machine decisions
---

## 2026-02-05 - US-006
- What was implemented:
  - Created TargetInfo struct with HasTarget, Name, Level, CurrentHealth, MaxHealth, Position, Hostility, IsDead
  - Added TargetHostility enum (Neutral, Hostile, Friendly) for target faction mapping
  - Added helper properties: IsHostile, IsFriendly, IsNeutral, HealthPercent
  - Added IsHealthBelowPercent/IsHealthAbovePercent threshold methods
  - Added Character.CharacterName field to GameStubs for target name
  - Added GetTargetInfo(), GetCachedTargetInfo(), UpdateTargetInfo() to GameStateReader
  - Converts Faction enum to TargetHostility (Enemy->Hostile, Friendly/Player->Friendly, Neutral->Neutral)
  - Added OnTargetInfoChanged event for reactive updates
  - Extended PositionTracker to track target info at 10Hz alongside position, vitals, and combat state
- Files changed:
  - src/ErenshorGlider/GameState/TargetInfo.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerControl.CurrentTarget returns the targeted Character (null if no target)
  - TargetInfo.NoTarget static property provides a consistent "no target" state
  - Faction enum maps to hostility: Enemy = Hostile, Player/Friendly = Friendly, Neutral = Neutral
  - Character.transform.position gives target world position (via MonoBehaviour inheritance)
  - PositionTracker now tracks position, vitals, combat state, and target info - serves as central state tracker
---

## 2026-02-05 - US-007
- What was implemented:
  - Created EntityInfo struct with Name, Type (EntityType enum), Position, Level, Hostility, CurrentHealth, MaxHealth, HealthPercent, IsDead, Distance
  - Added EntityType enum: Mob, NPC, Node, Corpse
  - Added helper properties: IsHostile, IsFriendly, IsNeutral, IsMob, IsNPC, IsNode, IsCorpse, CanBeAttacked
  - Added threshold methods: IsHealthBelowPercent, IsHealthAbovePercent
  - Extended GameStubs with NPC, SimPlayer, ResourceNode, LootableCorpse classes
  - Added GetNearbyEntities(), GetCachedNearbyEntities(), UpdateNearbyEntities() to GameStateReader
  - Scans for Character, NPC, ResourceNode, and LootableCorpse using UnityEngine.Object.FindObjectsOfType
  - Sorts entities by distance and skips already-looted corpses
  - Added OnNearbyEntitiesChanged event for reactive updates
  - Extended PositionTracker to track nearby entities at 10Hz alongside other state
  - Added NearbyEntitiesRadius property for configurable scan radius (default 50 units)
- Files changed:
  - src/ErenshorGlider/GameState/EntityInfo.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - UnityEngine.Object.FindObjectsOfType<T>() is the standard way to find all objects of a type in the scene
  - Need to be careful about duplicate detection since NPC inherits from Character - check by position to avoid adding same entity twice
  - Nearby entities scanning is expensive - 50 unit radius with 10Hz update may need tuning based on performance
  - EntityInfo uses readonly struct pattern for immutable snapshots - consistent with other game state types
  - PositionTracker now tracks position, vitals, combat state, target info, and nearby entities - central state tracker for all game state
---

## 2026-02-05 - US-008
- What was implemented:
  - Created ItemInfo struct with Name, Quantity, Quality (ItemQuality enum), SlotIndex, ItemId, MaxStackSize
  - Added ItemQuality enum: Poor, Common, Uncommon, Rare, Epic, Legendary
  - Added helper properties: IsCommon, IsUncommonOrBetter, IsRareOrBetter, IsEpicOrBetter, IsFullStack, CanStackMore
  - Created PlayerInventory struct with TotalSlots, FreeSlots, UsedSlots, Items list
  - Added helper methods: IsFull, IsNearlyFull, HasFreeSlots, CountItem, HasItem, GetItemsOfQuality, FillPercent
  - Extended GameStubs with PlayerInventory, InventorySlot, Item classes and ItemQuality enum
  - Added GetPlayerInventory(), GetCachedInventory(), UpdateInventory() to GameStateReader
  - Scans GameData.PlayerInv.ALLSLOTS[] for items, counting free slots and building item list
  - Added OnInventoryChanged event for reactive updates
  - Extended PositionTracker to track inventory state alongside other game state
  - PositionTracker now serves as central state tracker for: position, vitals, combat state, target info, nearby entities, and inventory
- Files changed:
  - src/ErenshorGlider/GameState/PlayerInventory.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerInv.ALLSLOTS[] provides array of all inventory slots
  - PlayerInventory.Empty is a static reference for comparing empty slots
  - ItemInfo uses readonly struct pattern - consistent with other game state types
  - Inventory includes quality information - useful for filtering vendor trash (poor quality items)
  - Inventory changes less frequently than combat state - could throttle updates separately if needed
  - PlayerInventory struct has helper methods like CountItem for checking consumable quantities
---
