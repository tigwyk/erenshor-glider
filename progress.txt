## Codebase Patterns
- Erenshor is a Unity game using BepInEx 5.x (Mono) for modding
- Use Harmony patches to hook into game methods (Prefix/Postfix)
- GameData singleton is the central access point for all game state
- GameData.PlayerControl.transform.position for player coordinates
- GameData.PlayerControl.Myself for player Character reference
- GameData.PlayerControl.CurrentTarget for current target
- Character.MyStats for health/mana/stats access
- Use BepInEx.Configuration for mod settings
- Target .NET Framework 4.7.2 or .NET Standard 2.0
- Build with `dotnet build` in project root (requires .NET SDK 8.0+)
- Plugin entry point is Plugin.cs with [BepInPlugin] attribute
- Use GameStubs/ for compile-time type safety without game DLLs
- nuget.config required with BepInEx NuGet feed (https://nuget.bepinex.dev/v3/index.json)
- GameState/ contains all game state reading logic
- Position tracking: Plugin.PositionTracker.CurrentPosition for cached position
- Vitals tracking: Plugin.PositionTracker.CurrentVitals for cached vitals
- CharacterStats has: CurrentHP, MaxHP, CurrentMP, MaxMP, Level, CurrentXP, XPToLevel
- Combat state tracking: Plugin.PositionTracker.CurrentCombatState for cached combat state
- PlayerCombat.InCombat for combat state, CastSpell.Casting for casting state, Character.Dead for alive/dead
- GameData.PlayerCombat for player combat controller
- GameData.PlayerControl.PlayerSpells for player spell casting component
- Target tracking: Plugin.PositionTracker.CurrentTargetInfo for cached target info
- Character.CharacterName for target/character display names
- Character.MyFaction for hostility (Faction enum: Player, Enemy, Neutral, Friendly)

---

## 2026-02-05 - US-001
- What was implemented:
  - Researched Erenshor's technical architecture
  - Documented Unity engine and BepInEx modding framework
  - Identified key game classes: GameData, Character, PlayerCombat, Hotkeys, Spell, Skill
  - Documented methods for reading game state (position, health, target, combat)
  - Documented methods for sending inputs (auto-attack, abilities, movement)
  - Listed all 6 character classes
- Files changed:
  - docs/technical-integration.md (created)
  - prd.json (committed with project)
- **Learnings for future iterations:**
  - Existing mods on GitHub (ErenshorQoL, ExtendedHotbars) are excellent references for API usage
  - GameData is a static singleton - most game state is accessed through it
  - CharacterStats likely has CurrentHP, MaxHP, CurrentMP, MaxMP properties (needs verification)
  - Private methods like Hotkeys.DoHotkeyTask() need reflection to call
  - Movement input simulation may be needed vs direct position manipulation
  - NPC.AggroOn() can be hooked to detect when player is attacked
  - Character.DoDeath() can be hooked to detect deaths
---

## 2026-02-05 - US-002
- What was implemented:
  - Created C# BepInEx 5.x plugin project structure
  - Set up ErenshorGlider.sln and ErenshorGlider.csproj with proper dependencies
  - Configured BepInEx.Core and UnityEngine.Modules NuGet packages
  - Added Plugin.cs with BepInPlugin attribute and basic initialization
  - Added PluginInfo.cs with plugin metadata constants
  - Created folder structure: src/ErenshorGlider/, profiles/, waypoints/
  - Added .editorconfig for C# code style consistency
  - Added .gitignore for build artifacts
  - Added Directory.Build.props for shared build configuration
  - Created README.md with setup and build instructions
- Files changed:
  - ErenshorGlider.sln (created)
  - src/ErenshorGlider/ErenshorGlider.csproj (created)
  - src/ErenshorGlider/Plugin.cs (created)
  - src/ErenshorGlider/PluginInfo.cs (created)
  - .editorconfig (created)
  - .gitignore (created)
  - Directory.Build.props (created)
  - README.md (created)
  - profiles/.gitkeep (created)
  - waypoints/.gitkeep (created)
- **Learnings for future iterations:**
  - Project uses SDK-style csproj with .NET Framework 4.7.2 target
  - BepInEx.Core 5.x and BepInEx.Analyzers packages provide base plugin functionality
  - UnityEngine.Modules 2022.3.20 provides Unity types (may need adjustment if Erenshor uses older Unity)
  - BepInEx.PluginInfoProps enables automatic plugin metadata generation
  - Plugin.cs inherits from BaseUnityPlugin which is a MonoBehaviour
  - Logger is accessible via base.Logger in Awake()
  - Build command: `dotnet build` (requires .NET SDK 8.0+)
---

## 2026-02-05 - US-003
- What was implemented:
  - Created PlayerPosition struct with X, Y, Z coordinates
  - Created GameStateReader class to read position from GameData.PlayerControl.transform.position
  - Created PositionTracker MonoBehaviour with 10Hz default update rate (configurable 1-100Hz)
  - Added GameStubs folder with stub types for compile-time safety without game DLLs
  - Added nuget.config with BepInEx NuGet feed for package resolution
  - Integrated PositionTracker into Plugin.Awake()
- Files changed:
  - src/ErenshorGlider/GameState/PlayerPosition.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (created)
  - src/ErenshorGlider/GameState/PositionTracker.cs (created)
  - src/ErenshorGlider/GameStubs/GameData.cs (created)
  - src/ErenshorGlider/Plugin.cs (modified)
  - nuget.config (created)
- **Learnings for future iterations:**
  - GameStubs approach allows building without game DLLs; swap to real types when Assembly-CSharp.dll is available
  - BepInEx packages are on separate NuGet feed (https://nuget.bepinex.dev) - must add to nuget.config
  - Position tracking via Unity Update() loop with Time.deltaTime accumulation for configurable Hz
  - Use events (OnPositionUpdated) for loose coupling between components
  - readonly struct for immutable data like positions
---

## 2026-02-05 - US-004
- What was implemented:
  - Created PlayerVitals struct with CurrentHealth, MaxHealth, CurrentMana, MaxMana, Level, CurrentXP, XPToLevel
  - Added percentage helpers (HealthPercent, ManaPercent, XPPercent) and threshold methods
  - Extended CharacterStats stub with Level, CurrentXP, XPToLevel fields
  - Added GetPlayerVitals(), GetCachedVitals(), UpdateVitals() to GameStateReader
  - Added OnVitalsChanged event for reactive updates
  - Extended PositionTracker to track vitals alongside position at 10Hz
  - Integrated vitals logging in Plugin.cs
- Files changed:
  - src/ErenshorGlider/GameState/PlayerVitals.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
  - src/ErenshorGlider/Plugin.cs (modified)
- **Learnings for future iterations:**
  - Access vitals via GameData.PlayerControl.Myself.MyStats (character stats component)
  - PositionTracker serves as the central state tracker - can be extended for other state
  - Use separate locks for position vs vitals to allow concurrent access
  - readonly struct pattern works well for immutable game state snapshots
  - Percentage helpers (e.g., IsHealthBelowPercent) useful for combat/rest decision thresholds
---

## 2026-02-05 - US-005
- What was implemented:
  - Created CombatState struct with InCombat, IsCasting, IsAlive properties
  - Added helper properties: IsDead, CanAct, IsIdle for decision-making convenience
  - Extended GameStubs with PlayerCombat and CastSpell classes
  - Added Character.Dead field to track alive/dead state
  - Added GameData.PlayerCombat static field
  - Added PlayerControl.PlayerSpells for CastSpell component access
  - Added GetCombatState(), GetCachedCombatState(), UpdateCombatState() to GameStateReader
  - Added OnCombatStateChanged event for reactive updates
  - Extended PositionTracker to track combat state at 10Hz alongside position and vitals
- Files changed:
  - src/ErenshorGlider/GameState/CombatState.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerCombat.InCombat tracks whether player is in combat mode (auto-attack enabled)
  - CastSpell.Casting tracks whether player is currently casting a spell
  - Character.Dead tracks death state - use !Dead for IsAlive
  - PositionTracker now tracks position, vitals, and combat state - serves as central state tracker
  - CombatState helper properties (CanAct, IsIdle) useful for state machine decisions
---

## 2026-02-05 - US-006
- What was implemented:
  - Created TargetInfo struct with HasTarget, Name, Level, CurrentHealth, MaxHealth, Position, Hostility, IsDead
  - Added TargetHostility enum (Neutral, Hostile, Friendly) for target faction mapping
  - Added helper properties: IsHostile, IsFriendly, IsNeutral, HealthPercent
  - Added IsHealthBelowPercent/IsHealthAbovePercent threshold methods
  - Added Character.CharacterName field to GameStubs for target name
  - Added GetTargetInfo(), GetCachedTargetInfo(), UpdateTargetInfo() to GameStateReader
  - Converts Faction enum to TargetHostility (Enemy->Hostile, Friendly/Player->Friendly, Neutral->Neutral)
  - Added OnTargetInfoChanged event for reactive updates
  - Extended PositionTracker to track target info at 10Hz alongside position, vitals, and combat state
- Files changed:
  - src/ErenshorGlider/GameState/TargetInfo.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerControl.CurrentTarget returns the targeted Character (null if no target)
  - TargetInfo.NoTarget static property provides a consistent "no target" state
  - Faction enum maps to hostility: Enemy = Hostile, Player/Friendly = Friendly, Neutral = Neutral
  - Character.transform.position gives target world position (via MonoBehaviour inheritance)
  - PositionTracker now tracks position, vitals, combat state, and target info - serves as central state tracker
---

## 2026-02-05 - US-007
- What was implemented:
  - Created EntityInfo struct with Name, Type (EntityType enum), Position, Level, Hostility, CurrentHealth, MaxHealth, HealthPercent, IsDead, Distance
  - Added EntityType enum: Mob, NPC, Node, Corpse
  - Added helper properties: IsHostile, IsFriendly, IsNeutral, IsMob, IsNPC, IsNode, IsCorpse, CanBeAttacked
  - Added threshold methods: IsHealthBelowPercent, IsHealthAbovePercent
  - Extended GameStubs with NPC, SimPlayer, ResourceNode, LootableCorpse classes
  - Added GetNearbyEntities(), GetCachedNearbyEntities(), UpdateNearbyEntities() to GameStateReader
  - Scans for Character, NPC, ResourceNode, and LootableCorpse using UnityEngine.Object.FindObjectsOfType
  - Sorts entities by distance and skips already-looted corpses
  - Added OnNearbyEntitiesChanged event for reactive updates
  - Extended PositionTracker to track nearby entities at 10Hz alongside other state
  - Added NearbyEntitiesRadius property for configurable scan radius (default 50 units)
- Files changed:
  - src/ErenshorGlider/GameState/EntityInfo.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - UnityEngine.Object.FindObjectsOfType<T>() is the standard way to find all objects of a type in the scene
  - Need to be careful about duplicate detection since NPC inherits from Character - check by position to avoid adding same entity twice
  - Nearby entities scanning is expensive - 50 unit radius with 10Hz update may need tuning based on performance
  - EntityInfo uses readonly struct pattern for immutable snapshots - consistent with other game state types
  - PositionTracker now tracks position, vitals, combat state, target info, and nearby entities - central state tracker for all game state
---

## 2026-02-05 - US-008
- What was implemented:
  - Created ItemInfo struct with Name, Quantity, Quality (ItemQuality enum), SlotIndex, ItemId, MaxStackSize
  - Added ItemQuality enum: Poor, Common, Uncommon, Rare, Epic, Legendary
  - Added helper properties: IsCommon, IsUncommonOrBetter, IsRareOrBetter, IsEpicOrBetter, IsFullStack, CanStackMore
  - Created PlayerInventory struct with TotalSlots, FreeSlots, UsedSlots, Items list
  - Added helper methods: IsFull, IsNearlyFull, HasFreeSlots, CountItem, HasItem, GetItemsOfQuality, FillPercent
  - Extended GameStubs with PlayerInventory, InventorySlot, Item classes and ItemQuality enum
  - Added GetPlayerInventory(), GetCachedInventory(), UpdateInventory() to GameStateReader
  - Scans GameData.PlayerInv.ALLSLOTS[] for items, counting free slots and building item list
  - Added OnInventoryChanged event for reactive updates
  - Extended PositionTracker to track inventory state alongside other game state
  - PositionTracker now serves as central state tracker for: position, vitals, combat state, target info, nearby entities, and inventory
- Files changed:
  - src/ErenshorGlider/GameState/PlayerInventory.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - GameData.PlayerInv.ALLSLOTS[] provides array of all inventory slots
  - PlayerInventory.Empty is a static reference for comparing empty slots
  - ItemInfo uses readonly struct pattern - consistent with other game state types
  - Inventory includes quality information - useful for filtering vendor trash (poor quality items)
  - Inventory changes less frequently than combat state - could throttle updates separately if needed
  - PlayerInventory struct has helper methods like CountItem for checking consumable quantities
---

## 2026-02-05 - US-009
- What was implemented:
  - Created BuffInfo struct with Name, BuffId, RemainingDuration, MaxDuration, Stacks, IconIndex, IsDebuff
  - Added helper properties: DurationPercent, IsExpired, IsDurationBelow, IsDurationAbove
  - Created BuffState struct with Buffs list, Debuffs list, and combined AllEffects
  - Added helper methods: HasBuff, HasDebuff, GetBuff, GetDebuff, HasBuffExpiringSoon, HasDebuffExpiringSoon
  - Extended GameStubs with CharacterBuffs, Buff classes
  - Added Character.MyBuffs field to access buffs/debuffs component
  - Added GetPlayerBuffs(), GetCachedPlayerBuffs(), UpdatePlayerBuffs() to GameStateReader
  - Added GetTargetBuffs(), GetCachedTargetBuffs(), UpdateTargetBuffs() for target buffs
  - Reads from CharacterBuffs.ActiveBuffs[] and ActiveDebuffs[] arrays
  - Added OnPlayerBuffsChanged and OnTargetBuffsChanged events for reactive updates
  - Extended PositionTracker to track player and target buff state
  - PositionTracker now serves as central state tracker for: position, vitals, combat state, target info, nearby entities, inventory, and buffs/debuffs
- Files changed:
  - src/ErenshorGlider/GameState/BuffInfo.cs (created)
  - src/ErenshorGlider/GameState/GameStateReader.cs (modified)
  - src/ErenshorGlider/GameState/PositionTracker.cs (modified)
  - src/ErenshorGlider/GameStubs/GameData.cs (modified)
- **Learnings for future iterations:**
  - Character.MyBuffs provides access to CharacterBuffs component
  - CharacterBuffs.ActiveBuffs[] contains beneficial effects
  - CharacterBuffs.ActiveDebuffs[] contains harmful effects
  - BuffInfo uses readonly struct pattern - consistent with other game state types
  - BuffState has helper methods for checking specific buffs (HasBuff, GetBuff) - useful for rotation decisions
  - Reading target buffs is important for decisions like "re-apply dot" or "don't over-cap debuffs"
  - Buff duration tracking (RemainingDuration/MaxDuration) enables pre-rebuffing logic
---

## 2026-02-05 - US-010
- What was implemented:
  - Created InputController class for sending simulated keyboard inputs
  - Added movement methods: MoveForward, MoveBackward, StrafeLeft, StrafeRight, TurnLeft, TurnRight, Jump
  - Added StopAllMovement method to release all movement keys
  - Added PressKey/ReleaseKey methods for fine-grained control
  - Added IsKeyPressed method to check current key state
  - Added OnKeyStateChanged event for tracking key changes
  - Created KeyCode enum with W, A, S, D, Space, arrows, number keys, F-keys, Tab, Enter, Escape
  - All movement methods support optional duration parameter for hold-and-release
  - Internal KeyStates dictionary tracks currently pressed keys
- Files changed:
  - src/ErenshorGlider/Input/InputController.cs (created)
- **Learnings for future iterations:**
  - Input simulation in BepInEx typically requires Harmony patching Input.GetKey/GetKeyDown
  - The current implementation uses a key state tracker that will be patched into Unity's input system
  - Duration-based movement (async) uses Task.Delay for timed release
  - KeyCode enum covers all game-relevant keys including ability bar (1-9) and targeting (Tab)
  - OnKeyStateChanged event enables other systems to react to input changes
  - PressKey/ReleaseKey pattern allows for simultaneous key presses (e.g., W + D for diagonal movement)
  - For actual input injection, will need Harmony patch on Unity's Input class or Windows API SendInput
---

## 2026-02-05 - US-011
- What was implemented:
  - Extended InputController with targeting methods: TargetNearestEnemy (Tab), ClearTarget (Esc)
  - Added TargetEntity(in EntityInfo) for direct entity targeting via reference
  - Added TargetEntityById(int instanceId) for targeting by Unity instance ID
  - Added OnTargetEntityRequested and OnTargetEntityByIdRequested events for integration
  - Added interaction methods: Interact, Loot, Talk, Gather (all use Enter key)
  - Added InteractWith(in EntityInfo) for combined targeting + interaction
  - Added CancelInteraction method (ESC key)
- Files changed:
  - src/ErenshorGlider/Input/InputController.cs (modified)
- **Learnings for future iterations:**
  - Targeting via Tab key is standard MMO pattern - cycles through nearby enemies
  - Direct entity targeting requires setting GameData.PlayerControl.CurrentTarget - needs reflection or Harmony
  - Event-based approach (OnTargetEntityRequested) allows external handlers to implement actual targeting logic
  - Interaction (Enter) is typically the same key for loot, talk, and gather in Erenshor
  - InteractWith combines targeting + interaction with 100ms delay for target registration
  - CancelInteraction uses ESC which also clears target - context-dependent behavior
---

## 2026-02-05 - US-012
- What was implemented:
  - Added UseAbilitySlot(int slot, delayMs) for activating abilities by hotbar slot (1-9)
  - Added UseAbility(KeyCode key, delayMs) for custom keybind activation
  - Added UseAbilityById(string abilityId) for direct spell/skill activation via game API
  - Added OnAbilityByIdRequested event for integration with game-specific ability systems
  - Added InputDelayMs property (default 50ms) for configurable input delay
  - Added RandomizationRangeMs property (default 25ms) for humanization variance
  - Added RandomGenerator property with SetRandomizationSeed method for reproducible behavior
  - ApplyRandomization method adds +/- variance to delays for human-like input
- Files changed:
  - src/ErenshorGlider/Input/InputController.cs (modified)
- **Learnings for future iterations:**
  - Ability slots 1-9 map to Alpha1-Alpha9 keycodes for standard hotbar
  - Direct ability activation by ID requires game-specific API - uses event pattern for extensibility
  - Humanization through random delay variation makes bot behavior less detectable
  - InputDelayMs controls base key press duration before release
  - RandomizationRangeMs adds +/- variance to each input for human-like inconsistency
  - SetRandomizationSeed enables reproducible testing while still allowing randomization
  - Minimum delay clamped to 10ms to prevent too-fast inputs that game might ignore
---
## 2026-02-05 - US-013
- What was implemented:
  - Created Navigation class for coordinate-based movement
  - Added MoveTo(x, y, z) and MoveTo(PlayerPosition) methods
  - Added HasReached and GetDistanceTo helper methods
  - Added StopMovement method to halt navigation
  - Added static CalculateDistance and CalculateDistanceSquared methods
  - CalculateDirection uses atan2 on X-Z plane for horizontal navigation
  - Supports 8-way movement: Forward, Backward, Left, Right, and 4 diagonals
  - MoveInDirection combines movement keys for diagonal paths
  - Added StoppingDistance property (default 2 units) for configurable arrival threshold
  - Added OnDestinationReached and OnMovementStuck events for state notification
  - Created NavigationDirection enum for 8 cardinal/intercardinal directions
- Files changed:
  - src/ErenshorGlider/Navigation/Navigation.cs (created)
- **Learnings for future iterations:**
  - Navigation operates on X-Z plane (horizontal) as Y is typically height/terrain
  - Angle to direction conversion uses 22.5-degree sectors (360/16 for 8 directions)
  - Simultaneous key presses (W+D for diagonal) require calling multiple InputController methods
  - StoppingDistance of 2 units prevents over-correcting at destination
  - CalculateDistanceSquared is useful for fast comparisons without sqrt overhead
  - MoveTo returns false if already at target - useful for state machine logic
  - OnDestinationReached event allows chaining navigation with other actions
---

## 2026-02-05 - US-014
- What was implemented:
  - Added stuck detection to Navigation class
  - Added CheckAndAttemptUnstick() method for periodic stuck checking
  - Added StuckDetectionThreshold property (default 2 seconds) for time-based detection
  - Added MaxUnstuckAttempts property (default 3) for retry limit
  - Added MovementProgressThreshold (default 0.5 units) for minimum movement
  - Added AttemptUnstick() with progressive strategies: jump, strafe, backup+jump, turn+jump
  - Added ResetStuckDetection() to clear stuck state when starting new navigation
  - Added IsStuck property to read current stuck state
  - Added UnstuckAttempts property to track retry count
  - OnMovementStuck event fires when max attempts reached
- Files changed:
  - src/ErenshorGlider/Navigation/Navigation.cs (modified)
- **Learnings for future iterations:**
  - Stuck detection tracks position over time, not just instantaneous state
  - MovementProgressThreshold prevents false positives from tiny position adjustments
  - Progressive unstuck strategies escalate from simple (jump) to complex (turn+jump)
  - Randomized strafe direction (left/right) prevents predictable unstuck patterns
  - ResetStuckDetection should be called when starting new navigation to clear previous state
  - OnMovementStuck event allows higher-level systems to handle persistent stuck situations
  - CheckAndAttemptUnstick returns true during unstuck attempts, allowing pause of navigation
---
## 2026-02-05 - US-015
- What was implemented:
  - Added FaceTarget(PlayerPosition) method to turn player toward position
  - Added FaceEntity(EntityInfo) overload to face entities
  - Added IsFacing() method to check if already facing target within tolerance
  - Added StopTurning() method to release turn keys
  - Added FacingTolerance property (default 10 degrees) for angle threshold
  - CalculateAngleToTarget uses atan2 on X-Z plane for horizontal facing
  - NormalizeAngleDelta keeps angle difference in [-180, 180] range
  - GetPlayerRotation stub added - TODO: implement with actual game rotation reading
  - FaceTarget returns true if turning started, false if already within tolerance
- Files changed:
  - src/ErenshorGlider/Navigation/Navigation.cs (modified)
- **Learnings for future iterations:**
  - Facing uses X-Z plane (horizontal) as Y is typically vertical/up
  - Angle normalization ensures correct turn direction (shortest path)
  - FacingTolerance prevents overshooting and oscillation when facing target
  - GetPlayerRotation needs actual implementation from transform.rotation
  - StopTurning should be called before new turn operations to prevent key stuck states
  - IsFacing useful for state machine checks before proceeding with actions requiring facing
---
## 2026-02-05 - US-016
- What was implemented:
  - Created Waypoint class with Position, Type, Name, Metadata, Delay properties
  - Created WaypointType enum: Normal, Vendor, Repair, Node, QuestGiver, QuestTurnIn, RestArea, DangerZone
  - Created WaypointPath class with Name, Waypoints list, Loop, ReverseAtEnd properties
  - Added Description, LevelRange, Zone, Metadata, CreatedAt, LastModified fields to WaypointPath
  - AddWaypoint, RemoveWaypoint, ClearWaypoints methods for path manipulation
  - Validate() method checks path integrity (name required, min 2 waypoints, vendor names, loop/reverse exclusivity)
  - SaveToFile/LoadFromFile methods using System.Text.Json
  - Created WaypointFileManager static class for directory management
  - GetWaypointFiles, SavePath, LoadPath, LoadAllPaths methods for file operations
  - SanitizeFileName helper removes invalid characters from filenames
  - JSON uses camelCase naming convention for compatibility
- Files changed:
  - src/ErenshorGlider/Waypoints/Waypoint.cs (created)
- **Learnings for future iterations:**
  - WaypointType enum enables special handling for vendors, repairs, quest NPCs
  - WaypointPath supports both Loop (return to start) and ReverseAtEnd (ping-pong) patterns
  - Validate() catches common errors before saving/using paths
  - WaypointFileManager uses ./waypoints/ directory by default
  - JSON serialization with WriteIndented makes files human-readable for manual editing
  - LastModified timestamp helps users identify recently updated paths
  - LevelRange and Zone metadata useful for filtering paths by character level/location
---
## 2026-02-05 - US-017
- What was implemented:
  - Created WaypointRecorder class for recording player paths
  - StartRecording(pathName) begins recording, StopRecording() returns WaypointPath
  - StopAndSave() stops and saves to file via WaypointFileManager
  - Update() method checks time/distance thresholds before capturing waypoints
  - MinDistanceBetweenWaypoints (default 5 units) prevents dense waypoint clusters
  - MinTimeBetweenRecords (default 1 second) prevents rapid-fire recording
  - RecordCurrentPosition() with optional waypoint type and name parameters
  - RecordVendor(), RecordRepair(), RecordNode() convenience methods
  - CancelRecording() discards current recording without saving
  - OnWaypointRecorded, OnRecordingStarted, OnRecordingStopped events
  - DefaultWaypointType property sets type for automatic recordings
- Files changed:
  - src/ErenshorGlider/Waypoints/WaypointRecorder.cs (created)
- **Learnings for future iterations:**
  - Time and distance thresholds prevent excessive waypoint density
  - Update() should be called regularly (e.g., every frame or at fixed interval) for accurate recording
  - Starting position is automatically recorded when StartRecording is called
  - Final position is automatically recorded when StopRecording is called
  - Event-based design allows UI to show recording status and waypoint count
  - Recorded path name auto-generates with timestamp if not provided
  - Manual recording (RecordCurrentPosition) bypasses thresholds for precise placement
---
## 2026-02-05 - US-018
- What was implemented:
  - Created WaypointPlayer class for following waypoint paths
  - PlayPath(name) loads from file, PlayPath(WaypointPath) for direct playback
  - FindNearestWaypoint() starts from closest waypoint when playback begins
  - Update() method handles navigation between waypoints and stuck detection
  - Supports Loop mode (return to start) and ReverseAtEnd mode (ping-pong)
  - OverrideLoop property allows overriding path's loop setting
  - Stop(), Pause(), Resume() methods for playback control
  - JumpToWaypoint(index) jumps to specific waypoint
  - SkipToNext(), SkipToPrevious() for manual waypoint navigation
  - CurrentWaypoint and CurrentWaypointIndex properties for state tracking
  - OnWaypointReached, OnPathCompleted, OnPlaybackStarted events
- Files changed:
  - src/ErenshorGlider/Waypoints/WaypointPlayer.cs (created)
- **Learnings for future iterations:**
  - FindNearestWaypoint prevents backtracking when starting mid-path
  - Update() should be called every frame/tick for smooth navigation
  - Waypoint delay (Delay property) not yet implemented - TODO: add delay waiting
  - ReverseAtEnd creates a "ping-pong" pattern (forward then backward)
  - CheckAndAttemptUnstick called during playback prevents getting stuck on geometry
  - OnWaypointReached event allows special handling for vendor/repair waypoints
  - CurrentWaypoint handles reversed index calculation internally
---
## 2026-02-05 - US-019
- What was implemented:
  - Created Ability class with Id, Name, Keybind, Cooldown, TriggersGcd, ManaCost, Range, RequiresTarget, IsChanneled, CastTime
  - Created Condition class with Type enum, Value, Operator, BuffName, CheckTarget
  - ConditionType enum: PlayerHealthPercent, PlayerManaPercent, PlayerLevel, TargetHealthPercent, TargetExists, TargetIsHostile, TargetIsDead, InCombat, NotInCombat, BuffPresent, BuffAbsent, BuffStackCount, CanAct
  - ComparisonOperator enum: Equal, NotEqual, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual
  - Condition.Evaluate() method checks condition against game state
  - RotationEntry class with AbilityId, Conditions list, Priority, Enabled, Description
  - RotationEntry.CanExecute() evaluates all conditions (AND logic)
  - CombatProfile class with Name, CharacterClass, Description, Abilities dict, Rotation list
  - GlobalCooldown, UseAutoAttack, MinHealthPercent, MinManaPercent properties
  - SortedRotation property returns rotation entries sorted by priority
  - SaveToFile/LoadFromFile using System.Text.Json
  - Validate() checks profile integrity
  - CombatProfileFileManager for directory operations (profiles/ directory)
- Files changed:
  - src/ErenshorGlider/Combat/CombatProfile.cs (created)
- **Learnings for future iterations:**
  - Conditions support both player and target state checking
  - CheckTarget flag in Condition allows checking target buffs vs player buffs
  - RotationEntry.Priority determines evaluation order (lower = higher priority)
  - Abilities dictionary allows reusing ability definitions across rotation entries
  - GlobalCooldown (GCD) prevents ability spamming
  - MinHealthPercent/MinManaPercent set thresholds for starting combat
  - Validate catches missing abilities referenced by rotation entries
  - CombatProfileFileManager mirrors WaypointFileManager pattern for consistency
---
## 2026-02-05 - US-020
- What was implemented:
  - US-020 was completed as part of US-019 (Combat profile data model)
  - CombatProfileFileManager.LoadProfile(name) loads profile by name
  - LoadFromFile(filePath) loads from specific path
  - LoadAllProfiles() loads all profiles from directory
  - GetProfileFiles() returns list of profile JSON files
  - Validate() checks profile structure and references
  - Uses ./profiles/ directory by default
- Files changed:
  - src/ErenshorGlider/Combat/CombatProfile.cs (created in US-019)
- **Learnings for future iterations:**
  - Loader functionality is integral to data model - implemented together
  - Validate catches missing abilities and empty rotations
  - Directory created automatically if doesn't exist
  - Error handling allows partial loading (continues on bad files)
  - Profiles stored with camelCase JSON naming for readability
---
## 2026-02-05 - US-021
- What was implemented:
  - Created TargetSelector class for intelligent target selection
  - FindBestTarget() returns best target based on multiple criteria
  - FindBestTarget(radius) overload for limited range search
  - HasValidTargets() and GetValidTargets() for target queries
  - BlacklistName(name) and BlacklistType(type) for filtering unwanted targets
  - ClearBlacklists() removes all filters
  - MaxLevelAbove (default 3) and MaxLevelBelow (default 10) for level range
  - MaxSearchRadius (default 50 units) limits search area
  - MaxWaypointDistance for path adherence (TODO: waypoint distance check)
  - PrioritizeAttackers (default true) prioritizes threatening targets
  - CompareTargetPriority sorts by: threat status, distance, level, health
  - OnTargetSelected and OnNoTargetFound events
- Files changed:
  - src/ErenshorGlider/Combat/TargetSelector.cs (created)
- **Learnings for future iterations:**
  - CanBeAttacked combines IsMob, IsHostile, and !IsDead checks
  - Name blacklist uses case-insensitive partial matching (flexible filtering)
  - Target priority: threat > distance > level (easier first) > health (lower first)
  - Level range prevents fighting mobs too high or too low
  - GetValidTargets returns sorted list by distance for manual selection
  - OnTargetSelected event allows logging/UI update when new target chosen
  - TODO: Add actual attacking player detection (requires combat state per entity)
  - TODO: Implement waypoint path distance checking
---
## 2026-02-05 - US-022
- What was implemented:
  - Created RotationExecutor class for combat rotation execution
  - LoadProfile(profile) and LoadProfile(name) for loading combat profiles
  - ExecuteNextAbility() evaluates rotation and executes best available ability
  - IsCasting property checks if GCD is active
  - Tracks individual ability cooldowns in _abilityLastUsed dictionary
  - Tracks GCD in _lastGcdTrigger timestamp
  - Checks mana cost before attempting ability
  - Checks target requirement and presence
  - Checks ability range vs target distance
  - Evaluates all RotationEntry conditions via CanExecute()
  - ParseKeybind() supports '1'-'9' and 'F1'-'F12' keybind formats
  - GetRemainingCooldown() returns cooldown time for specific ability
  - ClearCooldowns() resets all tracking
  - OnAbilityExecuted, OnNoAbilityReady, OnProfileLoaded events
  - UseAutoAttack property for auto-attack between abilities
- Files changed:
  - src/ErenshorGlider/Combat/RotationExecutor.cs (created)
- **Learnings for future iterations:**
  - SortedRotation returns entries sorted by Priority (lower = higher priority)
  - GCD check happens before any ability evaluation
  - Ability cooldowns are per-execution, not per-rotation pass
  - CanAct check ensures not casting and not dead before ability use
  - Keybind parsing is extensible for more formats (Shift+1, Ctrl+2, etc.)
  - TODO: Implement actual auto-attack functionality
  - GetDistanceToTarget uses Navigation.CalculateDistance for consistency
  - OnAbilityExecuted event allows UI to show which ability was used
---
